/*

Cyclical figurate numbers

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
all figurate (polygonal) numbers and are generated by the following formulae:

-------------------------------------------------------------
|  Triangle	   | P_3,n=n(n+1)/2	  |	 1, 3, 6, 10, 15, ...   |
|  Square	 	   | P_4,n=n2	 	      |  1, 4, 9, 16, 25, ...   |
|  Pentagonal  | P_5,n=n(3n−1)/2  |	 1, 5, 12, 22, 35, ...  |
|  Hexagonal	 | P_6,n=n(2n−1)    |	 1, 6, 15, 28, 45, ...  |
|  Heptagonal  | P_7,n=n(5n−3)/2  |	 1, 7, 18, 34, 55, ...  |
|  Octagonal   | P_8,n=n(3n−2)    |  1, 8, 21, 40, 65, ...  |
-------------------------------------------------------------

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three
interesting properties.

1. The set is cyclic, in that the last two digits of each number is the first
two digits of the next number (including the last number with the first).

2. Each polygonal type: triangle (P_3,127=8128), square (P_4,91=8281), and
pentagonal (P_5,44=2882), is represented by a different number in the set.

3. This is the only set of 4-digit numbers with this property.

Find the sum of the only ordered set of six cyclic 4-digit numbers for which
each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and
octagonal, is represented by a different number in the set.

*/
package main

import (
	"fmt"
)

const (
	triangle = 3
	square = 4
	pentagonal = 5
	hexagonal = 6
	heptagonal = 7
	octagonal = 8
)

func triangleFunc(n int) int {
	// order of operations enforced due to integral division
	return (n*(n+1))/2
}

func squareFunc(n int) int {
	return n*n
}

func pentagonalFunc(n int) int {
	// order of operations enforced due to integral division
	return (n*(3*n-1))/2
}

func hexagonalFunc(n int) int {
	return n*(2*n-1)
}

func heptagonalFunc(n int) int {
	// order of operations enforced due to integral division
	return (n*(5*n-3))/2
}

func octagonalFunc(n int) int {
	return n*(3*n-2)
}

type figurateKinds struct {
	// a single number n may be multiple kinds of figurate
	// e.g., []int{triangle, square}
	kinds []int
}

func (fk *figurateKinds) AddKind(kind int) {
	for _, k := range fk.kinds {
		if k == kind {
			panic("kind already set!")
		}
	}
	fk.kinds = append(fk.kinds, kind)
}

type figurateNumbers struct {
	kindsByNumber map[int]*figurateKinds
}

func newFigurateNumbers() *figurateNumbers {
	return &figurateNumbers{
		kindsByNumber: make(map[int]*figurateKinds),
	}
}

func (fn *figurateNumbers) AddNum(x int, kind int) {
	if fk, ok := fn.kindsByNumber[x]; ok {
    fk.AddKind(kind)
	} else {
		fk := new(figurateKinds)
		fk.AddKind(kind)
		fn.kindsByNumber[x] = fk
	}
}

// only tracks 4 digit numbers
type figurateLut struct {
	numByFirst2digits map[int]*figurateNumbers
}

func (lut *figurateLut) Add(x int, kind int) {
	if x < 1000 || x > 9999 {
		// ignore
		return
	}
	first2 := x / 100
	if fn, ok := lut.numByFirst2digits[first2]; ok {
		fn.AddNum(x, kind)
	} else {
		fn := newFigurateNumbers()
		fn.AddNum(x, kind)
		lut.numByFirst2digits[first2] = fn
	}
}

func newFigurateLut() *figurateLut {
	lut := &figurateLut {
		numByFirst2digits: make(map[int]*figurateNumbers),
	}
	for n := 1;; n++ {
		keepLooping := false
		r := triangleFunc(n)
		if r <= 9999 {
			keepLooping = true
			lut.Add(r, triangle)
		}
		r = squareFunc(n)
		if r <= 9999 {
			keepLooping = true
			lut.Add(r, square)
		}
		r = pentagonalFunc(n)
		if r <= 9999 {
			keepLooping = true
			lut.Add(r, pentagonal)
		}
		r = hexagonalFunc(n)
		if r <= 9999 {
			keepLooping = true
			lut.Add(r, hexagonal)
		}
		r = heptagonalFunc(n)
		if r <= 9999 {
			keepLooping = true
			lut.Add(r, heptagonal)
		}
		r = octagonalFunc(n)
		if r <= 9999 {
			keepLooping = true
			lut.Add(r, octagonal)
		}
		// done?
		if !keepLooping {
			break
		}
	}
	return lut
}

func solve(lut *figurateLut, numOrdering []int, haveKindsByNum map[int]int, wantKinds map[int]bool, first2digits int) (_ map[int]int, ok bool) {
	if len(wantKinds) == 6 {
		// first invocation
		// need to set first2digits
    for _, figNumbers := range lut.numByFirst2digits {
			for num, kinds := range figNumbers.kindsByNumber {
        for _, kind := range kinds.kinds {
					haveKindsByNum[num] = kind
					delete(wantKinds, kind)
					r, ok := solve(lut, []int{num}, haveKindsByNum, wantKinds, num%100)
					if ok {
						return r, true
					}
					// else: undo modifications
					delete(haveKindsByNum, num)
					wantKinds[kind] = true
				}
			}
		}
	} else {
		// not the first invocation
		// look for numbers starting with 'first2digits'
		if fn, ok := lut.numByFirst2digits[first2digits]; !ok {
			// no solutions here
			return nil, false
		} else {
			for num, kinds := range fn.kindsByNumber {
				for _, kind := range kinds.kinds {
					// do we care about this kind?
					if _, ok := wantKinds[kind]; !ok {
						// we don't
						continue
					}
					// ensure we don't already have number
					if _, ok := haveKindsByNum[num]; ok {
						// already have it
						continue
					}

					numOrdering = append(numOrdering, num)
					haveKindsByNum[num] = kind
					delete(wantKinds, kind)

					// Done?
          if len(wantKinds) == 0 {
						// check whether last number is cyclic with the first!
						if numOrdering[0] / 100 == numOrdering[len(numOrdering)-1] % 100 {
							return haveKindsByNum, true
						}
					} else {
						r, ok := solve(lut, numOrdering, haveKindsByNum, wantKinds, num%100)
						if ok {
							return r, true
						}
					}
					// else: undo modifications
					numOrdering = numOrdering[0:len(numOrdering)-1]
					delete(haveKindsByNum, num)
					wantKinds[kind] = true
				}
			}
		}
	}
	return nil, false
}

func sumOfSixCyclic() int {
	lut := newFigurateLut()
  haveKindsByNum := make(map[int]int)
	wantKinds := make(map[int]bool)
	wantKinds[triangle] = true
	wantKinds[square] = true
	wantKinds[pentagonal] = true
	wantKinds[hexagonal] = true
	wantKinds[heptagonal] = true
	wantKinds[octagonal] = true

	r, ok := solve(lut, nil, haveKindsByNum, wantKinds, 0)
	if !ok {
		panic("failed!")
	}

	fmt.Printf("r = %v\n", r)
	sum := 0
	for num, _ := range r {
		sum += num
	}
	return sum
}

func main() {
	fmt.Println(sumOfSixCyclic())
}
